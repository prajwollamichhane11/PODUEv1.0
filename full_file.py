# -*- coding: utf-8 -*-
"""ECG3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aSi3o_iH5PypYq2f_mLH8B25PyJNArG-
"""
# !pip install mne
# !pip install heartpy

# import mne
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import biosppy.signals.ecg as ecg
from scipy.integrate import quad
from scipy.signal import savgol_filter
from scipy.interpolate import CubicSpline

folder_path = "/content/drive/MyDrive/DIS_Dr_Liu/"
small_X_path = "small_X.npy"
small_y_path = "small_y.npy"

ecg_X = np.load(small_X_path, allow_pickle=True)
ecg_y = np.load(small_y_path, allow_pickle=True)

print('X: ', ecg_X.shape)
print('y: ', ecg_y.shape)

print(ecg_X[0])
print(ecg_y[0])

def pqrst_segmentation(input_file, patient_id, lead_id):
    '''
    Inputs:
        input_file: path to the numpy file, [str]
        patient_id: id of patient, [int]
        lead_id: lead range(0-11 inclusive). [int]
    Output:
        pqrst_data: 3D array
          where,
              1D: No. of heart beats/rpeaks detected
              2D: Indices of PQRST amplitudes
              3D: Amplitude of PQRST
          ,
        smoothed_ecg_data: 1D array
    -------------------------------------------
    For example:
    Inputs:
        input_file = './DIS/Datasets/small_X.npy'
        patient_id = 7
        lead_id = 1
    Output:
        array([[[ 1.50000000e+02,  1.26896875e+02],
            [ 1.86000000e+02, -4.25093750e+01],
            [ 1.99000000e+02,  3.07027679e+02],
            ...
            ]]]),
        array([194.76814516,  65.5378059 , -55.09052519, ...,  43.32979501,
        41.34527253,  38.91612903])
    '''
    # Load the ECG data from a file
    ecg_X = np.load(small_X_path, allow_pickle=True)

    # Extract the ECG data for the specified patient and lead
    X_ecg = ecg_X[patient_id, lead_id, :]

    # Smooth the ECG data using Savitzky-Golay filter
    smoothed_ecg_data = savgol_filter(X_ecg, window_length=30, polyorder=2)

    # Use the Christov's QRS complex detector to find R-peaks
    out = ecg.christov_segmenter(smoothed_ecg_data)
    r_peak_indices = list(out['rpeaks'])

    # Initialize lists to store Q, S, P, and T peak indices
    valid_r_peak_indices = []
    q_peak_indices = []
    s_peak_indices = []
    p_peak_indices = []
    t_peak_indices = []

    for r in r_peak_indices:
      # Search for Q-peak to the left of the R-peak
      q_peak = None
      for i in range(r - 1, 0, -1):
          # once the q-peak starts to raise this loop stops and latest q-peak is set to be the 'q'
          if smoothed_ecg_data[i] > smoothed_ecg_data[i + 1]:
              q_peak = i
              break

      # Search for S-peak to the right of the R-peak
      s_peak = None
      for i in range(r + 1, len(smoothed_ecg_data)):
          # once the s-valley starts to raise this loop stops and latest s-valley is set to be the 's'
          if smoothed_ecg_data[i] > smoothed_ecg_data[i - 1]:
              s_peak = i
              break
      q_peak_indices.append(q_peak)
      s_peak_indices.append(s_peak)
      valid_r_peak_indices.append(r)

      if q_peak is None or s_peak is None:
        # print("here")
        # print(r, q_peak, s_peak)
        valid_r_peak_indices.remove(r)
        q_peak_indices.remove(q_peak)
        s_peak_indices.remove(s_peak)
        continue

      # print(q_peak_indices)
      # print(r_peak_indices)
      # print(s_peak_indices)

      p_peak_indices = []
      t_peak_indices = []
      for i in range(len(q_peak_indices)):
        try:
          # Assuming P-peak is at 100 samples before the Q-peak
          if len(p_peak_indices) == 0:
              # for the first ECG wave, P peak is set to be the highest point before the Q of that wave
              if q_peak_indices[i] - 100 < 0:
                  seg_ecg_signal = smoothed_ecg_data[:q_peak_indices[i]]
                  max_amplitude_index = np.argmax(seg_ecg_signal)
                  p_peak_indices.append(max_amplitude_index)
              else:
                  seg_ecg_signal = smoothed_ecg_data[q_peak_indices[i] - 100:q_peak_indices[i]]
                  max_amplitude_index = np.argmax(seg_ecg_signal)
                  p_peak_indices.append(q_peak_indices[i] - 100 + max_amplitude_index)
          # Otherwise, P peak is the highest point in a 100 sized search window before Q
          else:
              seg_ecg_signal = smoothed_ecg_data[q_peak_indices[i] - 100:q_peak_indices[i] - 25]
              max_amplitude_index = np.argmax(seg_ecg_signal)
              p_peak_indices.append(q_peak_indices[i] - 100 + max_amplitude_index)
        except Exception as E:
          valid_r_peak_indices.pop()
          q_peak_indices.pop()
          s_peak_indices.pop()
          continue

      for i in range(len(s_peak_indices)):
          try:
            # Assuming T-peak is at 200 samples After the S-peak
            # for the last ECG wave, T peak is set to be the highest point after the S of that wave
            if i + 1 == len(s_peak_indices):
                seg_ecg_signal = smoothed_ecg_data[s_peak_indices[i] + 25:]
                max_amplitude_index = np.argmax(seg_ecg_signal)
                t_peak_indices.append(s_peak_indices[i] + 25 + max_amplitude_index)
            # Otherwise, T peak is the highest point in a 200 sized search window after S
            else:
                seg_ecg_signal = smoothed_ecg_data[s_peak_indices[i] + 25:s_peak_indices[i] + 200]
                max_amplitude_index = np.argmax(seg_ecg_signal)
                t_peak_indices.append(s_peak_indices[i] + 25 + max_amplitude_index)
          except Exception as E:
            valid_r_peak_indices.pop()
            q_peak_indices.pop()
            s_peak_indices.pop()
            p_peak_indices.pop()

    # Create a 3D numpy array to store P, Q, R, S, and T peak indices and their corresponding amplitudes
    pqrst_data = np.zeros((len(valid_r_peak_indices), 5, 2))

    # print(p_peak_indices)
    # print(q_peak_indices)
    # print(valid_r_peak_indices)
    # print(s_peak_indices)
    # print(t_peak_indices)

    # Fill the array with P, Q, R, S, and T peak indices and their corresponding amplitudes
    for i in range(len(valid_r_peak_indices)):
        pqrst_data[i][0] = [p_peak_indices[i], smoothed_ecg_data[p_peak_indices[i]]]
        pqrst_data[i][1] = [q_peak_indices[i], smoothed_ecg_data[q_peak_indices[i]]]
        pqrst_data[i][2] = [valid_r_peak_indices[i], smoothed_ecg_data[valid_r_peak_indices[i]]]
        pqrst_data[i][3] = [s_peak_indices[i], smoothed_ecg_data[s_peak_indices[i]]]
        pqrst_data[i][4] = [t_peak_indices[i], smoothed_ecg_data[t_peak_indices[i]]]

    return pqrst_data, smoothed_ecg_data

pqrst_segmentation_output, smoothed_ecg_data = pqrst_segmentation(small_X_path, 5, 6)

"""## P/R Ratio"""

def PR_ratio(pqrst_segmentation_output):
  pr_ratio = 0
  for i in range(len(pqrst_segmentation_output)):
    amp_p = pqrst_segmentation_output[i][0][1]
    amp_r = pqrst_segmentation_output[i][2][1]
    pr_ratio += amp_p/amp_r

  if len(pqrst_segmentation_output) != 0:
    return pr_ratio/len(pqrst_segmentation_output)
  else:
    return None

"""## RR Distance"""

def RR_Distance(pqrst_segmentation_output):
  rr_distance = 0
  for i in range(1,len(pqrst_segmentation_output)):
    rr_distance += pqrst_segmentation_output[i][2][0] - pqrst_segmentation_output[i-1][2][0]

  if len(pqrst_segmentation_output) - 1 != 0:
    return rr_distance/(len(pqrst_segmentation_output) - 1)
  else:
    return None

"""## P-Energy"""

def P_Energy(pqrst_segmentation_output, smoothed_ecg_data):
  p_energy = 0
  for i in range(len(pqrst_segmentation_output)):
    indx_pi = int(pqrst_segmentation_output[i][0][0]) - 25
    indx_pf = int(pqrst_segmentation_output[i][0][0]) + 25
    if indx_pi >= 0 and indx_pf <= 5000:
      amps = smoothed_ecg_data[indx_pi:indx_pf]
      p_energy += np.trapz(amps, x=range(indx_pi, indx_pf))

  if len(pqrst_segmentation_output) != 0:
    return p_energy/len(pqrst_segmentation_output)
  else:
    return None

"""## T-Energy"""

def T_Energy(pqrst_segmentation_output, smoothed_ecg_data):
  t_energy = 0
  for i in range(len(pqrst_segmentation_output)):
    indx_ti = int(pqrst_segmentation_output[i][4][0]) - 25
    indx_tf = int(pqrst_segmentation_output[i][4][0]) + 25
    if indx_ti >=0 and indx_tf <= 5000:
      amps = smoothed_ecg_data[indx_ti:indx_tf]
      t_energy += np.trapz(amps, x=range(indx_ti, indx_tf))

  if len(pqrst_segmentation_output) != 0:
    return t_energy/len(pqrst_segmentation_output)
  else:
    return None

"""## PQ Distance"""

def PQ_distance(pqrst_segmentation_output):
  pq_dist = 0
  for i in range(len(pqrst_segmentation_output)):
    indx_p = pqrst_segmentation_output[i][0][0]
    indx_q = pqrst_segmentation_output[i][1][0]

    pq_dist += indx_q - indx_p
    print(pq_dist)
  if len(pqrst_segmentation_output) != 0:
    return pq_dist/len(pqrst_segmentation_output)
  else:
    return None

"""## QT Interval"""

def QT_interval(pqrst_segmentation_output):
  qt_seg = 0
  for i in range(len(pqrst_segmentation_output)):
    indx_t = pqrst_segmentation_output[i][4][0]
    indx_q = pqrst_segmentation_output[i][1][0]
    try:
      qt_seg += (indx_t - indx_q)/RR_Distance(pqrst_segmentation_output)
    except Exception as E:
      return None

  if len(pqrst_segmentation_output) != 0:
    return qt_seg/len(pqrst_segmentation_output)
  else:
    return None

"""## ST Slope"""

def ST_slope(pqrst_segmentation_output):
  st_slope = 0
  for i in range(len(pqrst_segmentation_output)):
    indx_t = pqrst_segmentation_output[i][4][0]
    indx_s = pqrst_segmentation_output[i][3][0]
    amp_t = pqrst_segmentation_output[i][4][1]
    amp_s = pqrst_segmentation_output[i][3][1]

    st_slope += (amp_t - amp_s)/(indx_t - indx_s)

  if len(pqrst_segmentation_output) != 0:
    return st_slope/len(pqrst_segmentation_output)
  else:
    return None

"""## PR Slope"""

def PR_slope(pqrst_segmentation_output):
  pr_slope = 0
  for i in range(len(pqrst_segmentation_output)):
    indx_r = pqrst_segmentation_output[i][2][0]
    indx_p = pqrst_segmentation_output[i][0][0]
    amp_r = pqrst_segmentation_output[i][2][1]
    amp_p = pqrst_segmentation_output[i][0][1]

    pr_slope += (amp_r - amp_p)/(indx_r - indx_p)

  if len(pqrst_segmentation_output) != 0:
    return pr_slope/len(pqrst_segmentation_output)
  else:
    return None

"""## QRS Energy"""

def QRS_Energy(pqrst_segmentation_output, smoothed_ecg_data):
  qrs = 0
  for i in range(len(pqrst_segmentation_output)):
    indx_q = int(pqrst_segmentation_output[i][1][0])
    indx_s = int(pqrst_segmentation_output[i][3][0])

    amps = smoothed_ecg_data[indx_q:indx_s]

    qrs += np.trapz(amps, x=range(indx_q, indx_s))

  if len(pqrst_segmentation_output) != 0:
    return qrs/len(pqrst_segmentation_output)
  else:
    return None

"""## R-S-Q"""

def RSQ(pqrst_segmentation_output):
  RSQ = 0
  for i in range(len(pqrst_segmentation_output)):
    amp_r = pqrst_segmentation_output[i][2][1]
    amp_s = pqrst_segmentation_output[i][3][1]
    amp_q = pqrst_segmentation_output[i][1][1]

    RSQ += amp_r - amp_s - amp_q

  if len(pqrst_segmentation_output) != 0:
    return RSQ/len(pqrst_segmentation_output)
  else:
    return None

"""## Heart Rate"""

def Heart_Rate(pqrst_segmentation_output):
  r_peaks = []
  for i in range(len(pqrst_segmentation_output)):
    r_peaks.append(int(pqrst_segmentation_output[i][2][0]))

  if len(r_peaks) != 0:
    rr_intervals = np.diff(r_peaks)

    average_rr_interval = np.mean(rr_intervals)
    heart_rate = 60 / average_rr_interval

    return heart_rate
  else:
    return None
  
def find_peaks(ecg_data, n):
  # to collect r peaks, n=2
  return int(ecg_data[n][0])

def normalize_list(lst):
    min_val = min(lst)
    max_val = max(lst)
    normalized_lst = [(x - min_val) / (max_val - min_val) for x in lst]
    return normalized_lst

def cubic_spline_peaks_valleys(r_peak_indices, normalized_ecg):
  x = np.array(r_peak_indices)
  y = np.array(normalized_ecg[r_peak_indices])

  cs = CubicSpline(x, y)

  xs = np.linspace(min(x), max(x), 5000)
  ys = cs(xs)

  # Compute the first derivative of the cubic spline function
  derivative_1 = cs.derivative()

  # Generate points on the derivative curve
  deriv_xs = np.linspace(min(x), max(x), 5000)
  deriv_ys = derivative_1(deriv_xs)

  # Find indices where the derivative changes sign
  sign_changes = np.where(np.diff(np.sign(deriv_ys)))[0]

  # Identify highs and lows based on the sign changes
  highs = [int(deriv_xs[i]) for i in sign_changes if deriv_ys[i] > 0]
  lows = [int(deriv_xs[i]) for i in sign_changes if deriv_ys[i] < 0]

  return highs, lows, ys

def EDR_time_ratio(highs, lows):
  comp_lis = highs + lows
  st = sorted(comp_lis)

  TR = []
  for i in range(len(st)):
    try:
      if st[i] in lows and st[i+1] in highs and st[i+2] in lows:
        tr = (st[i+2] - st[i+1])/(st[i+1] - st[i])
        TR.append(tr)
    except Exception as e:
      continue
  try:
    tr = sum(TR)/len(TR)
    return tr
  except Exception as e:
    return None

def EDR_energy_ratio(highs, lows, ys):
  def integrand(t):
    return np.abs(np.interp(t, np.arange(len(ys)), ys))**2

  comp_lis = highs + lows
  st = sorted(comp_lis)

  EDR = []

  for i in range(len(st)):
    try:
      if st[i] in lows and st[i+1] in highs and st[i+2] in lows:
        exp, error = quad(integrand, st[i+1], st[i+2])
        ins, error = quad(integrand, st[i], st[i+1])
        EDR.append(exp/ins)

    except Exception as e:
      continue
  try:
    edr = sum(EDR)/len(EDR)
    return edr
  except Exception as e:
    return None


"""## For 2164 patients and 12 Leads"""

df = pd.DataFrame()

for patient_id in range(2164):
  for lead_id in range(12):
    print(patient_id, lead_id)
    pqrst_segmentation_output, smoothed_ecg_data = pqrst_segmentation(small_X_path, patient_id, lead_id)

    # Calculate ECG features using the segmented signal
    pr_ratio = PR_ratio(pqrst_segmentation_output)
    rr_distance = RR_Distance(pqrst_segmentation_output)
    p_energy = P_Energy(pqrst_segmentation_output, smoothed_ecg_data)
    t_energy = T_Energy(pqrst_segmentation_output, smoothed_ecg_data)
    pq_distance = PQ_distance(pqrst_segmentation_output)
    qt_interval = QT_interval(pqrst_segmentation_output)
    st_slope = ST_slope(pqrst_segmentation_output)
    pr_slope = PR_slope(pqrst_segmentation_output)
    qrs_energy = QRS_Energy(pqrst_segmentation_output, smoothed_ecg_data)
    rsq = RSQ(pqrst_segmentation_output)
    heart_rate = Heart_Rate(pqrst_segmentation_output)

    try:
      ## derived features
      r_peak_indices = []
      for ecg_data in pqrst_segmentation_output:
        r_peak_indices.append(find_peaks(ecg_data,2))
      normalized_ecg = np.array(normalize_list(smoothed_ecg_data))
      highs, lows, ys = cubic_spline_peaks_valleys(r_peak_indices, normalized_ecg)
      
      edr_time_ratio = EDR_time_ratio(highs, lows)
      edr_energy_ratio = EDR_energy_ratio(highs, lows, ys)
    except Exception as e:
      edr_time_ratio = None
      edr_energy_ratio = None

    # Store the results in the DataFrame
    df = df.append({
      "patient_id": patient_id,
      "lead_id": lead_id + 1,
      "pr_ratio": pr_ratio,
      "rr_distance": rr_distance,
      "p_energy": p_energy,
      "t_energy": t_energy,
      "pq_distance": pq_distance,
      "qt_interval": qt_interval,
      "st_slope": st_slope,
      "pr_slope": pr_slope,
      "qrs_energy": qrs_energy,
      "rsq": rsq,
      "heart_rate": heart_rate,
      "edr_time_ratio": edr_time_ratio,
      "edr_energy_ratio": edr_energy_ratio
    }, ignore_index=True)

df.to_csv("features.csv")